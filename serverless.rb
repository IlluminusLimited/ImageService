require 'yaml'
require 'aws-sdk-secretsmanager'

serverless_command = ARGV[0]

unless serverless_command
  puts "\n\nServerless command argument is required! Command should be used like so:\nruby serverless.rb command stage\n\n"
  return
end

stage = ARGV[1]

unless stage
  puts "\n\nStage argument is required! Command should be used like so:\nruby serverless.rb command stage\n\n"
  return
end

# We will always use the credentials file unless ARGV[2] is explicitly set to 'false' like in the .travis.yml file
use_aws_credentials_file = ARGV[2] != 'false'

supported_stages = %w[dev prod]

unless supported_stages.include? stage
  puts "\n\nUnsupported stage: #{stage}. Valid stages are: #{supported_stages}\n\n"
  return
end

puts "\nBuilding serverless.yml from serverless_template.yml with correct bucket name for stage: #{stage}"


serverless_file = File.read('serverless_template.yml')

puts "Doing what fucking serverless can't figure out. Getting secret for auth token"

client = Aws::SecretsManager::Client.new(region: 'us-east-1')

secret_response = client.get_secret_value(secret_id: "image-service-#{stage}", version_stage: 'AWSCURRENT')
token = JSON.parse(secret_response.secret_string)['create-image-token']

serverless_file.gsub!('AUTH_TOKEN_CHANGE_ME', token)

serverless = YAML.load(serverless_file)
bucket_name = serverless['custom']['imageUploadBucket']

unless bucket_name
  puts "\n\nFailed to find the uploader bucket in the serverless_template.yml file.\n\n"
  return
end

puts "Found Bucket name: #{bucket_name}"

supported_stages.each { |supported_stage| bucket_name.gsub!(/-?#{supported_stage}\Z/, '') }

# puts "Trimmed bucket name to not include stage suffix: #{bucket_name}"

s3_name = 'S3Bucket' + bucket_name.gsub('${self:provider.stage}', stage).gsub(/[-.]/, '').capitalize
s3_name_no_env = 'S3Bucket' + bucket_name.gsub('${self:provider.stage}', '').gsub(/[-.]/, '').capitalize

puts "Looking for resource name starting with: #{s3_name} or #{s3_name_no_env}"

# puts "Looking through keys: #{serverless['resources']['Resources'].keys}"
found_keys = serverless['resources']['Resources'].keys.select { |key| /#{s3_name}.*/.match(key) }
found_keys += serverless['resources']['Resources'].keys.select { |key| /#{s3_name_no_env}.*/.match(key) }

if found_keys.size > 1
  puts "\n\nFound more than one possible bucket name. Not sure what to do: #{found_keys}\n\n"
  return
end

if found_keys.size < 1
  puts "\nFailed to find a resource matching: \"#{s3_name}\". Found Keys: #{found_keys}\n\n"
  return
end

new_bucket_name = bucket_name.gsub('${self:provider.stage}', stage)

puts "New bucket name: #{new_bucket_name}"
serverless['custom']['imageUploadBucket'] = new_bucket_name

new_s3_name = 'S3Bucket' + bucket_name.gsub('${self:provider.stage}', stage).gsub(/[-.]/, '').capitalize

puts "New s3 resource name: #{new_s3_name}"
serverless['resources']['Resources'][new_s3_name] = serverless['resources']['Resources'].delete(found_keys.first)


unless use_aws_credentials_file
  serverless['provider'].delete('profile')
  puts "Deleted profile statement to not corrupt sls deploy"
end

puts "Writing new serverless.yml"

warning_message = <<-WARNING
# Do not edit this file, it is automatically generated by serverless.rb, any changes will be overridden
#
# The reason this file is generated from serverless.rb is because of a
# stupid limitation of serverless where keys can't be changed with variable substitutions
# https://github.com/serverless/serverless/issues/2486
# https://github.com/serverless/serverless/issues/2749
WARNING
File.open('serverless.yml', 'w') { |file| file.write(warning_message + serverless.to_yaml) }

puts "\nCalling Serverless with command: #{serverless_command}\n\n"

return_code = nil
output = []
r, io = IO.pipe
fork do
  return_code = system("sls #{serverless_command} --stage #{stage} -v", out: io, err: :out)
end
io.close
r.each_line { |l| puts l; output << l.chomp }

raise 'Serverless command failed!' if return_code
